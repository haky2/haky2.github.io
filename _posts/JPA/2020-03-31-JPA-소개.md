---
title: JPA 소개
tags: 
    - jpa
categories: JPA
layout: post
---

## SQL을 직접 다룰 때 발생하는 문제점
#### 반복 작업
- 데이터베이스는 데이터 중심의 구조를 가지므로 객체를 데이터베이스에 직접 저장하거나 조회활 수는 없다
- 개발자가 SQL과 JDBC API를 사용해서 변환 작업을 직접 해주어야 한다
- 무수히 많은 SQL과 JDBC API를 작성해야 한다

#### SQL에 의존적인 개발
- 데이터 접근 계층을 사용해서 SQL을 숨겨도 어쩔 수 없이 DAO를 열어서 어떤 SQL이 실행되는지 확인해야 한다
- 엔티티를 신뢰하고 사용할 수 없고, DAO를 열어서 모두 확인해야 한다
- 물리적으로는 데이터 접근 계층에 숨기는 데 성공했을지 몰라도 논리적으로는 엔티티와 아주 강한 의존관계를 가지고 있다
- 강한 의존관계 때문에 DAO의 CRUD 코드와 SQL 대부분을 변경해야 정상적으로 코드가 실행된다

```java
class MemberService {
  ...
  public void process(String id) {
    Member member = memberDAO.find(id);

    member.getTeam(); // ???
    member.getOrder().getDelivery(); // ???
  }
}
```

---

## 패러다임의 불일치
#### 상속
- 객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다

#### 연관관계
- 객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회한다
- 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다
- 객체는 참조가 있는 방향으로만 조회가 가능한 반면, 테이블은 외래 키 하나로 양방향 조회가 가능하다
- 객체를 테이블에 맞추어 모델링을 하게 되면 좋은 객체 모델링을 기대하기 어렵고 결국 객체지향의 특징을 잃어버린다
- 객체지향 모델링을 사용하면 객체를 테이블에 저장하거나 조회하기 쉽지 않다. 이를 처리하기 위해 소모하는 비용이 높아진다

#### 객체 그래프 탐색
- 객체는 마음껏 객체 그래프를 탐색할 수 있어야 한다
- SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다
- 비지니스 로직에 따라 객체 그래프가 다르므로 함부로 객체 그래프를 탐색할 수 없다
- 객체 그래프 탐색이 가능한지 알아보려면 데이터 접근 계층인 DAO를 열어서 SQL을 직접 확인해야 한다(SQL에 종속적)

#### 비교
- 데이터베이스는 기본 키의 값으로 각 로우를 구분한다
- 객체는 동일성(==, 주소 값 비교) 비교와 동등성(equals(), 내부의 값 비교) 비교를 한다

---

## JPA란 무엇인가?
#### JPA 소개
- JPA는 자바 진영의 ORM 기술 표준이다
- ORM은 객체와 관계형 데이터베이스를 매핑한다는 뜻이다
- ORM 프레임워크는 패러다임의 불일치 문제를 개발자 대신 해결해준다
- JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 사용해야한다
- 대표적은 ORM 프레임워크는 Hibernate이다
- JPA 덕분에 특정 구현 기술에 대한 의존도를 줄일 수 있고 다른 구현 기술로 손쉽게 이동할 수 있다

#### JPA 사용 이유
- 생산성 : CRUD용 SQL을 개발자가 직접 작성하지 않아도 된다 (객체 중심으로 설계 가능)
- 유지보수 : SQL과 JDBC API 코드를 JPA가 대신 처리해주므로 유지보수해야 하는 코드 수가 줄어든다
- 패러다임 불일치 해결 : 상속, 연관관계, 객체 그래프 탐색, 비교 등의 패러다임 불일치를 해결해준다
- 성능 : 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공한다 (캐시 등)
- 데이터 접근 추상화와 벤더 독립성 : 애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해서 특정 데이터베이스 기술에 종속되지 않도록 한다
- 표준 : 자바 진영의 ORM 기술 표준이므로 다른 구현 기술로 손쉽게 변경할 수 있다



