---
title: 병렬 데이터 처리와 성능
tags: 
    - java
    - parallel data
categories: JAVA
layout: post
---

## 병렬 스트림
- 병렬 스트림
    - 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크(덩어리)로 분할한 스트림
    - parallelStream으로 생성
    - 각각의 프로세서가 각각의 청크를 처리하도록 할당할 수 있음

```

public static long parallelSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
                 .limit(n)
//                 병렬 스트림으로 처리
                 .parallel()
//                 순차 스트림으로 처리
//                 .sequential()
                 .reduce(0L, Long::sum);
}

```

## 스트림의 성능
- 병렬 프로그래밍이 무조건적으로 빠르진 않음
- iterate의 병렬처리
    - 본질적으로 순차적인 구조
    - 이전 연산의 결과에 따라 다음 함수의 입력이 달라진다
    - 박싱된 객체를 생성하므로 이를 다시 언박싱하는 과정이 필요 (특화되지 않은 스트림을 처리할 때는 오토박싱, 언박싱 등의 오버헤드 수반)
    - 병렬로 실행될 수 있도록 독립적인 청크로 분할하기 어려움
    - 병렬로 처리되도록 해도 순차처리 방식과 크게 다른 점이 없고, 오히려 스레드를 할당하는 오버헤드만 증가
- 올바른 자료구조를 선택해야 병렬 실행도 최적의 성능을 발휘할 수 있음
- 병렬화의 과정
    - 스트림을 재귀적으로 분할
    - 각 서브스트림을 서로 다른 스레드의 리듀싱 연산으로 할당
    - 이들 결과를 하나의 값으로 합쳐야 함
- 코어 간에 데이터 전송 시간보다 훨씬 오래 걸리는 작업만 병렬로 다른 코어에서 수행하는 것이 바람직


## 병렬 스트림의 올바른 사용법
- 데이터 레이스 : 멀티 쓰레드 환경에서 여러 쓰레드가 공유자원에 동시에 접근할 때 쓰레드의 경쟁에 유발되는 문제
- 데이터 레이스를 동기화로 해결하면 결국 병렬화라는 특성이 없어짐
- 병렬 스트림을 올바로 동작하려면 공유된 가변 상태를 피해야 함
- 순차 스트림과 병렬 스트림을 직접 측정하여 효율적인 것을 사용
- 박싱 주의. 기본형 특화 스트림을 사용(IntStream, LongStrea, DoubleStream)
- 병렬 스트림에서 성능이 떨어지는 연산을 피하자. (limit, findFirst 등의 요소의 순서에 의존하는 연산)
- 스트림에서 수행하는 전체 파이프라인 연산 비용 고려 (연산 비용이 높다면 병렬 스트림으로 성능을 개선할 수 있는 가능성이 있음)
- 소량의 데이터에서는 불필요
- 적절한 자료구조 사용
- 스트림의 특성과 파이프라인의 중간 연산을 정확히 파악하여 사용
- 최종 연산의 병합 과정의 비용 고려

스트림 소스 | 분해성
--- | ---
ArrayList | 훌륭함
LinkedList | 나쁨
IntStream.range | 훌륭함
Stream.iterate | 나쁨
HashSet | 좋음
TreeSet | 좋음


## 포크/조인 프레임워크
- 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음, 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계
- ExecutorService interface 구현 : 스레드 풀의 작업자 스레드에 분산 할당
- 스레드 풀을 이용하려면 RecursiveTask<R>을 상속 받아 compute를 구현해야 함
- compute() : 태스크를 서브태스크로 분할하는 로직과 더 이상 분할할 수 없을 때 개별 서브태스크의 결과를 생산할 알고리즘을 정의 (분할정복 알고리즘의 병렬화 버전)
- 분할정복(divide and conquer) 알고리즘 : 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘

```

if (태스크가 충분히 작거나 더 이상 분할할 수 없으면) {
    순차적으로 태스크 계산
} else {
    태스크를 두 서브태스크로 분할
    태스크가 다시 서브태스크로 분할되도록 이 메서드를 재귀적으로 호출
    모든 서브태스크의 연산이 완료될 때까지 기다림
    각 서브태스크의 결과를 합침
}

```

- ForkJoinPool은 정적 필드에 싱글턴으로 저장하여 하나만 생성하여 사용함
- fork메서드 : 다른 스레드로 생성한 태스크를 비동기로 실행
- join메서드 : 서브태스크의 결과를 읽거나 없다면 대기
- compute메서드 : 태스크의 동기 실행
- compute 실행하여 태스크 실행 > fork 실행하여 서브태스크 생성 > join 실행하여 결과 반환 


## 포크/조인 프레임워크를 제대로 사용하는 방법
- join 메서드는 태스크가 생산하는 결과가 준비될 때까지 호출자를 블록시킴. 따라서 두 서브태스크가 모두 시작된 다음에 join 호출
- RecursiveTask 내에서 ForkJoinPool의 invoke 사용하지 말고 compute나 fork 사용
- 한쪽 작업에는 fork, 한쪽 작업에는 compute를 호출하는 것이 효율적. 두 서브 태스크의 한 태스크에는 같은 스레드를 재사용할 수 있음
- 순차 처리보다 무조건 빠르지 않으므로, 성능 측정 후 사용

## 작업 훔치기 알고리즘
- 스레드의 할 일이 끝나면 유휴 상태로 바꾸는 것이 아닌, 다른 스레드 큐의 꼬리에서 작업을 훔쳐와서 처리
- 풀에 있는 작업자 스레드의 태스크를 재분배하고 균형을 맞출 때 사용

---

## Spliterator
- 분할할 수 있는 반복자
- 병렬 작업에 특화되어 있