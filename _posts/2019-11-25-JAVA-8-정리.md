---
title: JAVA 8 정리
tags: 
    - java
categories: JAVA
layout: post
---

## 동작 파라미터화

* 자주 바뀌는 요구사항에 효과적으로 대응 가능
* 어떻게 실행할 것인지 결정하지 않은 코드 블록
* 프레디케이트 : 선택 조건을 결정하는 것 (불린을 반환하는 함수)
* 메서드가 다양한 동작(전략)을 받아서 내부적으로 다양한 동작을 수행
* 전략 패턴 : 각 알고리즘(전략)을 캡슐화하는 알고리즘 패밀리를 정의해둔 다음에 런타임에 알고리즘을 선택하는 기법
* 공통으로 사용할 전략을 인터페이스로 만들어두고 각 전략에서 해당 인터페이스를 구현. 전략이 필요한 메소드에 전략을 전달하고 해당 전략의 메서드를 실행시킨다. >> 동작을 추상화
* 동작을 캡슐화한 다음에 메서드로 전달해서 메서드의 동작을 파라미터화
* 인터페이스 구현 > 익명 클래스 > 람다 표현식
* 메서드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달

---

## 람다 표현식
* 람다표현식 : 메서드로 전달할 수 있는 익명 함수를 단순화한 것
* 파라미터 리스트, 화살표, 람다의 바디로 구성
* (parameters) -> expression 표현식
* (parameters) -> { statements; } 구문
* 함수형 인터페이스라는 문맥에서 람다 표현식을 사용
* 함수형 인터페이스 : 정확히 하나의 추상 메서드를 지정하는 인터페이스 (Comparator, Runnable ...)
* 람다표현식 > 전체 표현식을 함수형 인터페이스의 인스턴스로 취급
* @FunctionalInterface
* Predicate, Consumer, Function ...
* 람다 캡처링 : 자유변수를 활용 가능 (final로 선언 됐거나 이와 같은 내용으로 사용 가능한 변수만)
* 람다가 정의된 메서드의 지역 변수의 값은 바꿀 수 없다 (클로저와의 차이)
* 메서드 레퍼런스 : 특정 메서드만을 호출하는 람다의 축약형
* 메서드명 앞에 구분자(::)를 붙이는 방식으로 활용
* ClassName::Method
* 생성자 레퍼런스 : ClassName::new
* 자바 컴파일러는 람다 표현식이 사용된 콘텍스트를 활용해서 람다의 파라미터 형식을 추로한다 (형식추론 >> 파라미터 타입 제거 가능)
* 실행 어라운드 패턴 : 코드 중간에 실행해야 하는 메서드에 꼭 필요한 코드)


---

## Stream

* 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소
* 스트림을 이용하면 선언형으로 컬렉션 데이터를 처리 가능 (데이터를 처리하는 임시 구현 코드 대신 질의로 표현 > 루프와 if 조건문 등의 제어 블록 없이 동작 구현)
* 멀티 스레드 코드 없이 병렬 처리 가능
* 스트림의 주제는 계산(필터,소트,맵), 컬렉션의 주제는 데이터(자료구조)
    * fileter : 람다를 인수로 받아 스트림에서 특정 요소를 제외시킴 (predicate를 인수로 받음)
    * distinct : 중복을 필터링
    * map : 람다를 이용해서 한 요소를 다른 요소로 변환하거나 정보를 추출
    * flatmap : 하나의 평면화된 스트림을 반환. 스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행
    * limit : 스트림 크기를 축소한다
    * skip : n개 요소를 제외한 스트림을 반환
    * collect : 스트림을 다른 형식으로 변환

```
import static java.util.stream.Collectors.toList;
List<String> threeHighCaloricDishNames = menu.stream()
                                             .filter(d -> d.getCalories() > 300)
                                             .distinct()
                                             .map(Dish::getName)
                                             .limit(3)
                                             .skip(2)
                                             .collect(toList());
```

* 컬렉션 : 현재 자료구조가 포함하는 모든 값을 메모리에 저장. 모든 요소는 컬렉션에 추가하기 전에 계산되어야 함 (dvd)
* 스트림 : 요청할 때만 요소를 계산하는 고정된 자료구조. (streaming)
* 스트림은 한번만 소비할 수 있음. 다시 탐색하려면 새로운 스트림을 만들어야 함
* 스트림은 내부 반복을 이용하므로 반복 과정을 신경쓰지 않아도 됨
* 중간연산 : filter, map 처럼 스트림을 반환하면서 다른 연산과 연결될 수 있는 연산. 파이프라인 구성 가능. 결과값 없음
* 최종연산 : count, collect 처럼 스트림 파이프라인을 처리해서 스트림이 아닌 결과를 반환하는 연산
* 검색과 매칭 메소드 제공
    * anyMatch : 프레디케이트가 주어진 스트림에서 적어도 한 요소와 일치하는지 확인. 불린 반환
    * allMatch : 스트림의 모든 요소가 주어진 프레디케이트와 일치하는지 검사
    * noneMatch : allMAtch와 반대연산 (일치하는 요소가 없는지 확인)
    * findAny : 현재 스트림에서 임의의 요소를 반환 (Optional 클래스로 반환. 값이 없을때 어떻게 처리할 것인지 강제하는 기능 제공. null 익셉션 피하기 위해)
    * findFirst : 첫 번째 요소 반환 (병렬 실행에서는 첫 번째 요소를 찾기 어려움)
* 리듀싱 : 모든 스트림 요소를 처리해서 값으로 도출하는 과정
* 두개의 인수 (초기값, 오퍼레이터 표현식)

```
int sum = numbers.stream().reduce(0, (a,b) -> a+b);
int sum = numbers.stream().reduce(0, Integer::sum);
Optional<Integer> max = numbers.stream().reduce(0, Integer::max);
```

* 기본형 특화 스트림
* 숫자 스트림 : mapToInt, mapToDouble, mapToLong
    * 객체 스트림으로 복원 : boxed
    * 값으로 스트림 만들기 : Stream.of
    * 배열로 스트림 만들기 : Arrays.stream
    * 파일로 스트림 만들기 : Files.lines
    * 함수로 스트림 만들기 : Stream.iterate, Stream.generate


### 참고
* [http://soomong.net/blog/2017/07/30/book-java8-in-action/](http://soomong.net/blog/2017/07/30/book-java8-in-action/)
* [https://www.sangkon.com/java8_study_part1/](https://www.sangkon.com/java8_study_part1/)
