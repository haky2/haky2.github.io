<h2 id="동작-파라미터화">동작 파라미터화</h2>

<ul>
  <li>자주 바뀌는 요구사항에 효과적으로 대응 가능</li>
  <li>어떻게 실행할 것인지 결정하지 않은 코드 블록</li>
  <li>프레디케이트 : 선택 조건을 결정하는 것 (불린을 반환하는 함수)</li>
  <li>메서드가 다양한 동작(전략)을 받아서 내부적으로 다양한 동작을 수행</li>
  <li>전략 패턴 : 각 알고리즘(전략)을 캡슐화하는 알고리즘 패밀리를 정의해둔 다음에 런타임에 알고리즘을 선택하는 기법</li>
  <li>공통으로 사용할 전략을 인터페이스로 만들어두고 각 전략에서 해당 인터페이스를 구현. 전략이 필요한 메소드에 전략을 전달하고 해당 전략의 메서드를 실행시킨다. » 동작을 추상화</li>
  <li>동작을 캡슐화한 다음에 메서드로 전달해서 메서드의 동작을 파라미터화</li>
  <li>인터페이스 구현 &gt; 익명 클래스 &gt; 람다 표현식</li>
  <li>메서드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달</li>
</ul>

<hr />

<h2 id="람다-표현식">람다 표현식</h2>
<ul>
  <li>람다표현식 : 메서드로 전달할 수 있는 익명 함수를 단순화한 것</li>
  <li>파라미터 리스트, 화살표, 람다의 바디로 구성</li>
  <li>(parameters) -&gt; expression 표현식</li>
  <li>(parameters) -&gt; { statements; } 구문</li>
  <li>함수형 인터페이스라는 문맥에서 람다 표현식을 사용</li>
  <li>함수형 인터페이스 : 정확히 하나의 추상 메서드를 지정하는 인터페이스 (Comparator, Runnable …)</li>
  <li>람다표현식 &gt; 전체 표현식을 함수형 인터페이스의 인스턴스로 취급</li>
  <li>@FunctionalInterface</li>
  <li>Predicate, Consumer, Function …</li>
  <li>람다 캡처링 : 자유변수를 활용 가능 (final로 선언 됐거나 이와 같은 내용으로 사용 가능한 변수만)</li>
  <li>람다가 정의된 메서드의 지역 변수의 값은 바꿀 수 없다 (클로저와의 차이)</li>
  <li>메서드 레퍼런스 : 특정 메서드만을 호출하는 람다의 축약형</li>
  <li>메서드명 앞에 구분자(::)를 붙이는 방식으로 활용</li>
  <li>ClassName::Method</li>
  <li>생성자 레퍼런스 : ClassName::new</li>
  <li>자바 컴파일러는 람다 표현식이 사용된 콘텍스트를 활용해서 람다의 파라미터 형식을 추로한다 (형식추론 » 파라미터 타입 제거 가능)</li>
  <li>실행 어라운드 패턴 : 코드 중간에 실행해야 하는 메서드에 꼭 필요한 코드)</li>
</ul>

<hr />

<h3 id="참고">참고</h3>
<ul>
  <li>http://soomong.net/blog/2017/07/30/book-java8-in-action/</li>
  <li>https://www.sangkon.com/java8_study_part1/</li>
</ul>
